<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>世界の歴史タイムライン（スタンドアロン版 v2）</title>
  <style>
    :root{
      --bg:#f8fafc; --panel:#ffffff; --ink:#0f172a; --muted:#475569; --line:#cbd5e1;
      --shadow:0 10px 30px rgba(2,6,23,.06);
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{margin:0; font-family: system-ui, -apple-system, Segoe UI, Roboto, "ヒラギノ角ゴ ProN", "Hiragino Kaku Gothic ProN", "Yu Gothic UI", "YuGothic", "Meiryo", sans-serif; background:var(--bg); color:var(--ink);}
    .wrap{max-width:1400px; margin:0 auto; padding:24px; display:grid; gap:24px}
    .hdr{display:flex; gap:12px; align-items:flex-end; justify-content:space-between; flex-wrap:wrap}
    h1{margin:0; font-size:clamp(20px, 2.6vw, 28px); font-weight:800; letter-spacing:.3px}
    .sub{color:#475569}
    .card{background:var(--panel); border:1px solid #e5e7eb; border-radius:18px; box-shadow:var(--shadow)}
    .side{padding:16px; display:flex; flex-direction:column; gap:18px}
    .grid{display:grid; grid-template-columns:1fr; gap:24px}
    @media (min-width:1024px){ .grid{grid-template-columns: 360px 1fr;} }
    .btn{appearance:none; border:1px solid #e5e7eb; background:#fff; padding:8px 12px; border-radius:12px; cursor:pointer; box-shadow:0 2px 8px rgba(2,6,23,.04); transition:.15s}
    .btn:hover{transform:translateY(-1px); box-shadow:0 6px 18px rgba(2,6,23,.08)}
    .btn[primary]{background:#0f172a; color:#fff; border-color:#0f172a}
    .btn:disabled{opacity:.5; cursor:not-allowed}
    .row{display:flex; gap:8px; flex-wrap:wrap}
    label{font-size:12px; color:#64748b}
    input, textarea{width:100%; border:1px solid #e5e7eb; border-radius:12px; padding:10px 12px; font:inherit; color:var(--ink); background:#fff}
    textarea{height:160px; font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace; font-size:12px}
    .help{font-size:12px; color:#64748b; line-height:1.6}
    .canvas{padding:12px; overflow:hidden}
    #svg{width:100%; height:680px; display:block}
    .tick{stroke:#94a3b8; stroke-dasharray:2 3; opacity:.7}
    .axis{stroke:#475569;}
    .bgrow{fill:#ffffff}
    .bgrow:nth-child(2n){fill:#f8fafc}
    .period{rx:8; ry:8; stroke:rgba(0,0,0,.08)}
    .region{font-weight:700; fill:#0f172a}
    .label{font-size:11px; fill:#0f172a}
    .tooltip{position:absolute; pointer-events:none; background:rgba(0,0,0,.85); color:#fff; padding:6px 10px; border-radius:10px; font-size:12px; box-shadow:0 8px 26px rgba(0,0,0,.25); opacity:0; transition:opacity .12s}
    .legend{display:flex; gap:8px; flex-wrap:wrap; align-items:center}
    .chip{width:12px; height:12px; border-radius:4px; display:inline-block; border:1px solid rgba(0,0,0,.08)}
  </style>
</head>
<body>
  <div class="wrap">
    <div class="hdr">
      <div>
        <h1>世界の歴史タイムライン（比較可視化）</h1>
        <div class="sub">同じ時間軸で、日本・西洋・東南アジア・南米などの時代の長さを横バーで比較。</div>
      </div>
      <div class="row">
        <button id="fit" class="btn" primary>全体表示</button>
        <button id="zin" class="btn">ズーム +</button>
        <button id="zout" class="btn">ズーム −</button>
        <button id="exsvg" class="btn">SVG保存</button>
        <button id="expng" class="btn">PNG保存</button>
      </div>
    </div>

    <div class="grid">
      <aside class="card side">
        <section>
          <h3 style="margin:0 0 8px;font-size:14px">表示範囲（年）</h3>
          <div class="row">
            <label style="flex:1">開始
              <input id="start" type="number" value="-14000">
            </label>
            <label style="flex:1">終了
              <input id="end" type="number" value="2025">
            </label>
          </div>
          <div class="row" style="margin-top:6px">
            <button class="btn preset" data-p="-14000,2025">全期間</button>
            <button class="btn preset" data-p="0,2025">西暦〜</button>
            <button class="btn preset" data-p="1000,2025">1000年〜</button>
            <button class="btn preset" data-p="1500,2025">1500年〜</button>
            <button class="btn preset" data-p="1800,2025">1800年〜</button>
            <button class="btn preset" data-p="1900,2025">1900年〜</button>
          </div>
          <div class="row" style="margin-top:8px">
            <button id="apply" class="btn" style="width:100%" primary>表示範囲を適用</button>
          </div>
        </section>

        <section>
          <h3 style="margin:0 0 8px;font-size:14px">レイヤー（地域 ON/OFF）</h3>
          <div id="toggles" class="row" style="flex-direction:column; align-items:flex-start"></div>
        </section>

        <section>
          <h3 style="margin:0 0 8px;font-size:14px">データの入出力</h3>
          <p class="help">JSONを編集して独自の時代区分を追加できます（BCEはマイナス）</p>
          <textarea id="json"></textarea>
          <div class="row" style="margin-top:6px">
            <button id="applyjson" class="btn">JSONを反映</button>
            <button id="resetjson" class="btn">JSONをリセット</button>
          </div>
        </section>

        <section class="help">
          <p>注記：各時代の境界は諸説あります。ここでは代表的な年代を便宜採用。</p>
          <p>バーのホバーで詳細。ドラッグでパン、ホイールでズーム。</p>
        </section>
      </aside>

      <main class="card canvas" id="canvas">
        <svg id="svg" xmlns="http://www.w3.org/2000/svg"></svg>
        <div id="tip" class="tooltip"></div>
      </main>
    </div>
  </div>

<script>
// ===== データ初期値 =====
const NOW = 2025;
const INITIAL = [
  { name: "日本", periods: [
    { name: "縄文", start: -14000, end: -300 },
    { name: "弥生", start: -300, end: 300 },
    { name: "古墳", start: 250, end: 538 },
    { name: "飛鳥", start: 538, end: 710 },
    { name: "奈良", start: 710, end: 794 },
    { name: "平安", start: 794, end: 1185 },
    { name: "鎌倉", start: 1185, end: 1333 },
    { name: "室町", start: 1336, end: 1573 },
    { name: "安土桃山", start: 1573, end: 1603 },
    { name: "江戸", start: 1603, end: 1868 },
    { name: "明治", start: 1868, end: 1912 },
    { name: "大正", start: 1912, end: 1926 },
    { name: "昭和", start: 1926, end: 1989 },
    { name: "平成", start: 1989, end: 2019 },
    { name: "令和", start: 2019, end: NOW }
  ]},
  { name: "西洋（ヨーロッパ）", periods: [
    { name: "先史（新石器〜青銅器）", start: -7000, end: -1200 },
    { name: "古典古代", start: -800, end: 476 },
    { name: "中世", start: 476, end: 1453 },
    { name: "ルネサンス", start: 1300, end: 1600 },
    { name: "近世", start: 1500, end: 1800 },
    { name: "産業革命期", start: 1760, end: 1914 },
    { name: "20世紀（現代）", start: 1914, end: 1991 },
    { name: "同時代", start: 1991, end: NOW }
  ]},
  { name: "東南アジア（代表的王朝）", periods: [
    { name: "ホアビン文化", start: -10000, end: -2000 },
    { name: "扶南", start: 50, end: 550 },
    { name: "真臘", start: 550, end: 802 },
    { name: "クメール帝国", start: 802, end: 1431 },
    { name: "シュリーヴィジャヤ", start: 650, end: 1377 },
    { name: "マジャパヒト", start: 1293, end: 1527 },
    { name: "アユタヤ", start: 1351, end: 1767 },
    { name: "ラタナコーシン（バンコク）", start: 1782, end: NOW },
    { name: "植民地期（英・仏・蘭）", start: 1511, end: 1957 }
  ]},
  { name: "南米（アンデス中心）", periods: [
    { name: "ノルテ・チコ（カラル）", start: -3500, end: -1800 },
    { name: "チャビン", start: -900, end: -200 },
    { name: "モチェ", start: 100, end: 700 },
    { name: "ナスカ", start: 100, end: 800 },
    { name: "ワリ", start: 600, end: 1100 },
    { name: "ティワナク", start: 500, end: 1000 },
    { name: "チムー", start: 900, end: 1470 },
    { name: "インカ帝国", start: 1438, end: 1533 },
    { name: "スペイン植民地期", start: 1533, end: 1821 },
    { name: "独立・共和期", start: 1821, end: NOW }
  ]}
];

let data = JSON.parse(JSON.stringify(INITIAL));
let visible = Object.fromEntries(data.map(d=>[d.name,true]));

// ===== DOM =====
const svg = document.getElementById('svg');
const tip = document.getElementById('tip');
const toggles = document.getElementById('toggles');
const jsonArea = document.getElementById('json');
const inputStart = document.getElementById('start');
const inputEnd = document.getElementById('end');

// 安全なID生成（UTF-8対応・英数字のみ）
function safeIdFromString(s){
  return 'chk_' + Array.from(s).map(ch => ch.codePointAt(0).toString(16)).join('');
}

function colorFor(name){
  const palette = ["#2563eb","#10b981","#f59e0b","#ef4444","#8b5cf6","#06b6d4","#f97316","#22c55e","#e11d48","#a855f7","#14b8a6","#84cc16","#d946ef","#f43f5e","#0ea5e9","#6366f1","#65a30d","#fb7185","#ea580c","#059669"];
  let h=0; for(let i=0;i<name.length;i++) h=((h<<5)-h)+name.charCodeAt(i);
  return palette[Math.abs(h)%palette.length];
}
function fmtYear(y){ return y<0 ? `紀元前 ${Math.abs(y)}` : `${y}`; }
function domain(){
  let min=Infinity, max=-Infinity;
  data.forEach(r=>r.periods.forEach(p=>{ if(p.start<min)min=p.start; if(p.end>max)max=p.end; }));
  return [min, Math.max(max, NOW)];
}

// ===== Layout =====
let margin = {top:40, right:24, bottom:40, left:140};
let view = {w: svg.clientWidth || 1200, h: svg.clientHeight || 680};
let xDomain = domain();
function xScale(v){ const [s,e]=xDomain; const L= view.w - margin.left - margin.right; return margin.left + (v - s) / (e - s) * L; }

function yBands(){
  const regs = data.filter(r=>visible[r.name]);
  const innerTop = margin.top;
  const rowH = Math.max(28, (view.h - margin.top - margin.bottom) / Math.max(regs.length, 1));
  return { regs, rowH, y:(name)=> innerTop + regs.findIndex(r=>r.name===name)*rowH };
}

function ticks(){
  const s = xDomain[0], e = xDomain[1], span = e - s;
  let step = 5;
  if (span>10000) step=2000; else if(span>5000) step=1000; else if(span>2000) step=500;
  else if(span>1000) step=200; else if(span>500) step=100; else if(span>200) step=50;
  else if(span>100) step=20; else if(span>50) step=10; else step=5;
  const start = Math.ceil(s/step)*step;
  const arr=[]; for(let t=start; t<=e; t+=step) arr.push(t);
  return {arr, step};
}

// ===== Render =====
function clear(svg){ while(svg.firstChild) svg.removeChild(svg.firstChild); }

function draw(){
  view = {w: svg.clientWidth || 1200, h: svg.clientHeight || 680};
  clear(svg);

  // grid + axis
  const {arr} = ticks();
  const g = document.createElementNS("http://www.w3.org/2000/svg","g");
  svg.appendChild(g);

  // grid lines
  arr.forEach(t=>{
    const x = xScale(t);
    const line = document.createElementNS(svg.namespaceURI,"line");
    line.setAttribute("x1", x); line.setAttribute("x2", x);
    line.setAttribute("y1", margin.top); line.setAttribute("y2", view.h - margin.bottom);
    line.setAttribute("class","tick");
    line.setAttribute("stroke","#94a3b8");
    line.setAttribute("stroke-dasharray","2 3");
    g.appendChild(line);

    const label = document.createElementNS(svg.namespaceURI,"text");
    label.textContent = fmtYear(t);
    label.setAttribute("x", x); label.setAttribute("y", view.h - margin.bottom + 16);
    label.setAttribute("text-anchor","middle");
    label.setAttribute("fill","#334155");
    label.setAttribute("font-size","11");
    g.appendChild(label);
  });

  // x-axis baseline
  const base = document.createElementNS(svg.namespaceURI,"line");
  base.setAttribute("x1", margin.left);
  base.setAttribute("x2", view.w - margin.right);
  base.setAttribute("y1", view.h - margin.bottom);
  base.setAttribute("y2", view.h - margin.bottom);
  base.setAttribute("stroke","#475569");
  base.setAttribute("stroke-width","1.2");
  svg.appendChild(base);

  // rows
  const {regs, rowH, y} = yBands();
  // backgrounds
  regs.forEach((r,i)=>{
    const rect = document.createElementNS(svg.namespaceURI,"rect");
    rect.setAttribute("x", margin.left);
    rect.setAttribute("y", y(r.name));
    rect.setAttribute("width", view.w - margin.left - margin.right);
    rect.setAttribute("height", rowH);
    rect.setAttribute("fill", i%2 ? "#f8fafc" : "#ffffff");
    svg.appendChild(rect);
  });

  // region labels
  regs.forEach(r=>{
    const text = document.createElementNS(svg.namespaceURI,"text");
    text.textContent = r.name;
    text.setAttribute("x", margin.left - 10);
    text.setAttribute("y", y(r.name) + rowH/2 + 4);
    text.setAttribute("text-anchor","end");
    text.setAttribute("fill","#0f172a");
    text.setAttribute("font-size","13");
    text.setAttribute("font-weight","700");
    svg.appendChild(text);
  });

  // periods
  regs.forEach(r=>{
    r.periods.forEach(p=>{
      const x1 = xScale(p.start), x2 = xScale(p.end);
      const w = Math.max(1, x2 - x1);
      const rect = document.createElementNS(svg.namespaceURI,"rect");
      rect.setAttribute("x", x1);
      rect.setAttribute("y", y(r.name) + 4);
      rect.setAttribute("width", w);
      rect.setAttribute("height", rowH - 8);
      rect.setAttribute("rx","8"); rect.setAttribute("ry","8");
      rect.setAttribute("fill", colorFor(p.name));
      rect.setAttribute("stroke","rgba(0,0,0,0.08)");
      rect.classList.add("period");
      rect.addEventListener("mousemove", (ev)=>{
        tip.innerHTML = `<div style="font-weight:700;margin-bottom:2px">${p.name}</div>
          <div style="opacity:.9;font-size:12px">${fmtYear(p.start)} 〜 ${fmtYear(p.end)}</div>
          <div style="opacity:.8;font-size:11px;margin-top:2px">地域：${r.name}</div>`;
        tip.style.left = (ev.pageX + 14) + "px";
        tip.style.top  = (ev.pageY + 14) + "px";
        tip.style.opacity = 1;
      });
      rect.addEventListener("mouseleave", ()=> tip.style.opacity = 0);
      svg.appendChild(rect);

      // label inside if room
      const label = document.createElementNS(svg.namespaceURI,"text");
      label.textContent = p.name;
      label.setAttribute("x", x1 + 8);
      label.setAttribute("y", y(r.name) + rowH/2 + 4);
      label.setAttribute("fill", "#0f172a");
      label.setAttribute("font-size","11");
      svg.appendChild(label);
      // remove if too wide (approx)
      const need = 7 * p.name.length + 16;
      if (w < need) svg.removeChild(label);
    });
  });
}

// ===== Toggles / JSON =====
function refreshToggles(){
  toggles.innerHTML='';
  data.forEach(r=>{
    const id = safeIdFromString(r.name);
    const wrap = document.createElement('label');
    wrap.style.display='flex'; wrap.style.alignItems='center'; wrap.style.gap='8px'; wrap.style.cursor='pointer';
    wrap.innerHTML = `<input id="${id}" type="checkbox" ${visible[r.name]?'checked':''}> <span>${r.name}</span>`;
    toggles.appendChild(wrap);
    wrap.querySelector('input').addEventListener('change', (e)=>{ visible[r.name]=e.target.checked; draw(); });
  });
}
function resetJSON(){ jsonArea.value = JSON.stringify(data, null, 2); }
refreshToggles(); resetJSON();

// ===== Zoom & Pan =====
let isPanning=false, panStartX=0, panStartDomain=[...xDomain];
svg.addEventListener('mousedown', (e)=>{ isPanning=true; panStartX=e.clientX; panStartDomain=[...xDomain]; e.preventDefault(); });
window.addEventListener('mouseup', ()=> isPanning=false);
window.addEventListener('mousemove', (e)=>{
  if(!isPanning) return;
  const dx = e.clientX - panStartX;
  const L = (view.w - margin.left - margin.right);
  const span = panStartDomain[1] - panStartDomain[0];
  const shift = -dx / L * span;
  xDomain = [panStartDomain[0] + shift, panStartDomain[1] + shift];
  draw();
});
svg.addEventListener('wheel', (e)=>{
  e.preventDefault();
  const mouseX = e.offsetX;
  const [s,e2]=xDomain;
  const L = (view.w - margin.left - margin.right);
  const t = Math.min(1, Math.max(0, (mouseX - margin.left) / L)); // clamp
  const span = e2 - s;
  const factor = e.deltaY < 0 ? 0.85 : 1.15; // zoom in / out
  const newSpan = span * factor;
  const newS = s + (span - newSpan)*t;
  const newE = newS + newSpan;
  xDomain = [newS, newE];
  draw();
},{passive:false});

// ===== Controls =====
document.getElementById('fit').addEventListener('click', ()=>{ xDomain = domain(); inputStart.value = Math.floor(xDomain[0]); inputEnd.value = Math.ceil(xDomain[1]); draw(); });
document.getElementById('zin').addEventListener('click', ()=>{ svg.dispatchEvent(new WheelEvent('wheel', {deltaY:-100, bubbles:true})); });
document.getElementById('zout').addEventListener('click', ()=>{ svg.dispatchEvent(new WheelEvent('wheel', {deltaY:100, bubbles:true})); });

document.querySelectorAll('.preset').forEach(b=> b.addEventListener('click', ()=>{
  const [s,e] = b.dataset.p.split(',').map(Number);
  inputStart.value = s; inputEnd.value = e;
}));
document.getElementById('apply').addEventListener('click', ()=>{
  const s = Number(inputStart.value), e = Number(inputEnd.value);
  if (Number.isNaN(s) || Number.isNaN(e) || s>=e){ alert('開始年と終了年を確認してください（開始 < 終了）'); return; }
  xDomain = [s, e]; draw();
});

document.getElementById('applyjson').addEventListener('click', ()=>{
  try{
    const obj = JSON.parse(jsonArea.value);
    if(!Array.isArray(obj)) throw new Error('配列のJSONにしてください');
    obj.forEach(r=>{
      if(typeof r.name!=='string' || !Array.isArray(r.periods)) throw new Error('各要素に name と periods が必要です');
      r.periods.forEach(p=>{
        if(typeof p.name!=='string' || typeof p.start!=='number' || typeof p.end!=='number') throw new Error('periods は name/start/end を指定');
      });
    });
    data = obj;
    visible = Object.fromEntries(data.map(d=>[d.name,true]));
    refreshToggles();
    xDomain = domain();
    inputStart.value = Math.floor(xDomain[0]); inputEnd.value = Math.ceil(xDomain[1]);
    draw();
  }catch(err){
    alert('JSONの読み込みに失敗しました: '+err.message);
  }
});
document.getElementById('resetjson').addEventListener('click', ()=>{
  data = JSON.parse(JSON.stringify(INITIAL));
  visible = Object.fromEntries(data.map(d=>[d.name,true]));
  refreshToggles();
  resetJSON();
  xDomain = domain();
  inputStart.value = Math.floor(xDomain[0]); inputEnd.value = Math.ceil(xDomain[1]);
  draw();
});

// ===== Export =====
document.getElementById('exsvg').addEventListener('click', ()=>{
  const s = new XMLSerializer().serializeToString(svg);
  const blob = new Blob([s], {type:'image/svg+xml;charset=utf-8'});
  const a = document.createElement('a');
  a.href = URL.createObjectURL(blob);
  a.download = 'history_timeline.svg';
  a.click();
});

document.getElementById('expng').addEventListener('click', ()=>{
  const s = new XMLSerializer().serializeToString(svg);
  const img = new Image();
  const url = URL.createObjectURL(new Blob([s],{type:'image/svg+xml;charset=utf-8'}));
  img.onload = ()=>{
    const canvas = document.createElement('canvas');
    canvas.width = svg.clientWidth * 2;
    canvas.height = svg.clientHeight * 2;
    const ctx = canvas.getContext('2d');
    ctx.scale(2,2);
    ctx.fillStyle = '#ffffff';
    ctx.fillRect(0,0,canvas.width,canvas.height);
    ctx.drawImage(img,0,0);
    URL.revokeObjectURL(url);
    canvas.toBlob((blob)=>{
      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      a.download = 'history_timeline.png';
      a.click();
    });
  };
  img.src = url;
});

// ===== init =====
window.addEventListener('resize', draw);
xDomain = domain();
inputStart.value = Math.floor(xDomain[0]); inputEnd.value = Math.ceil(xDomain[1]);
draw();
</script>
</body>
</html>
